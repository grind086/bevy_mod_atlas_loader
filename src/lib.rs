#![doc = include_str!("../README.md")]

use bevy::{
    asset::{processor::LoadTransformAndSave, transformer::IdentityAssetTransformer, AssetPath},
    prelude::*,
    utils::HashMap,
};
use serde::{Deserialize, Serialize};

pub mod loader;

use loader::{TextureAtlasBuildLoader, TextureAtlasLoader, TextureAtlasSaver};

/// An asset processor that loads individual tile images, builds a texture atlas, then saves the compiled texture
/// atlas.
type TextureAtlasBuildProcessor = LoadTransformAndSave<
    TextureAtlasBuildLoader,
    IdentityAssetTransformer<TextureAtlasAsset>,
    TextureAtlasSaver,
>;

/// Provides a [`TextureAtlasAsset`] and associated asset loaders/savers.
///
/// See the [crate-level](self) documentation for more information.
pub struct AtlasLoaderPlugin;

impl Plugin for AtlasLoaderPlugin {
    fn build(&self, app: &mut App) {
        app.init_asset::<TextureAtlasAsset>()
            .register_asset_loader(TextureAtlasLoader)
            .register_asset_loader(TextureAtlasBuildLoader)
            .register_asset_processor(TextureAtlasBuildProcessor::new(
                IdentityAssetTransformer::new(),
                TextureAtlasSaver,
            ))
            .set_default_asset_processor::<TextureAtlasBuildProcessor>("atlas.ron");
    }
}

/// Stores a mapping from sub texture paths to the related area index.
///
/// Generated by [`TextureAtlasBuildLoader`].
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct TextureAtlasPaths {
    texture_ids: HashMap<AssetPath<'static>, usize>,
    path_indices: Vec<Option<AssetPath<'static>>>,
}

impl TextureAtlasPaths {
    /// Adds a texture with the given path. If the given path is `None`, no path will be associated with this index.
    fn add(&mut self, path: Option<AssetPath<'static>>) {
        if let Some(asset_path) = path.as_ref() {
            self.texture_ids
                .insert(asset_path.clone(), self.path_indices.len());
        }
        self.path_indices.push(path);
    }

    /// Retrieves the texture *section* index of the given `texture` path.
    pub fn texture_index<'a>(&self, texture: impl Into<AssetPath<'a>>) -> Option<usize> {
        self.texture_ids.get(&texture.into()).copied()
    }

    /// Returns the [`AssetPath`] associated with the given index, if any.
    pub fn texture_path(&self, index: usize) -> Option<&AssetPath<'static>> {
        if index < self.path_indices.len() {
            self.path_indices[index].as_ref()
        } else {
            None
        }
    }

    /// Creates a [`TextureAtlas`] handle for the given `texture` path.
    pub fn handle<'a>(
        &self,
        layout: Handle<TextureAtlasLayout>,
        texture: impl Into<AssetPath<'a>>,
    ) -> Option<TextureAtlas> {
        self.texture_index(texture.into())
            .map(|index| TextureAtlas { layout, index })
    }

    /// Retrieves the texture *section* rectangle of the given `texture` path.
    pub fn texture_rect<'a>(
        &self,
        layout: &TextureAtlasLayout,
        texture: impl Into<AssetPath<'a>>,
    ) -> Option<URect> {
        self.texture_index(texture.into())
            .map(|index| layout.textures[index])
    }
}

/// An [`Asset`] containing a full texture atlas. See [`TextureAtlas`] and [`TextureAtlasLayout`] for more information
/// on texture atlases.
///
/// This assets contains the following labelled sub-assets:
/// - `#layout`: A [`TextureAtlasLayout`] for the atlas.
/// - `#texture`: The [`Image`] texture for the atlas.
///
/// Indices into the atlas may be obtained from the initial tile texture paths using the [`TextureAtlasPaths`] that is
/// contained in this asset.
///
/// # Example
///
/// ```ignore
/// fn create_sprite_from_atlas_asset<'a>(
///     atlas: &TextureAtlasAsset,
///     path: impl Into<AssetPath<'a>>
/// ) -> Sprite {
///     Sprite::from_atlas_image(
///         atlas.texture.clone(),
///         atlas.handle(path),
///     )
/// }
/// ```
#[derive(Asset, TypePath, Clone)]
pub struct TextureAtlasAsset {
    pub layout: Handle<TextureAtlasLayout>,
    pub texture: Handle<Image>,
    pub paths: TextureAtlasPaths,
}

impl TextureAtlasAsset {
    /// Retrieves the texture *section* index of the given `texture` path.
    pub fn texture_index<'a>(&self, texture: impl Into<AssetPath<'a>>) -> Option<usize> {
        self.paths.texture_index(texture.into())
    }

    /// Returns the [`AssetPath`] associated with the given index, if any.
    pub fn texture_path(&self, index: usize) -> Option<&AssetPath<'static>> {
        self.paths.texture_path(index)
    }

    /// Creates a [`TextureAtlas`] handle for the given `texture` path.
    pub fn handle<'a>(&self, path: impl Into<AssetPath<'a>>) -> Option<TextureAtlas> {
        self.paths.handle(self.layout.clone(), path.into())
    }

    /// Creates a [`TextureAtlas`] handle for the given index.
    pub fn handle_from_index(&self, index: usize) -> TextureAtlas {
        TextureAtlas {
            layout: self.layout.clone(),
            index,
        }
    }
}
